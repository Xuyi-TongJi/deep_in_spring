package edu.seu.deep_in_spring.beanFactoryPostProcessor;

import org.mybatis.spring.mapper.MapperScannerConfigurer;
import org.springframework.beans.factory.support.AbstractBeanDefinition;
import org.springframework.beans.factory.support.BeanDefinitionBuilder;
import org.springframework.beans.factory.support.DefaultListableBeanFactory;
import org.springframework.context.annotation.AnnotationBeanNameGenerator;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.ConfigurationClassPostProcessor;
import org.springframework.context.support.GenericApplicationContext;
import org.springframework.core.annotation.AnnotationUtils;
import org.springframework.core.io.ClassPathResource;
import org.springframework.core.io.Resource;
import org.springframework.core.type.MethodMetadata;
import org.springframework.core.type.classreading.CachingMetadataReaderFactory;
import org.springframework.core.type.classreading.MetadataReader;
import org.springframework.stereotype.Component;
import java.io.IOException;
import java.util.Objects;
import java.util.Set;

public class TestBeanFactoryPostProcessor {
    public static void main(String[] args) throws IOException {
        //testConfigurationClassPostProcessor();
        //testMyBeanFactoryPostProcessor();
        //testBeanPostProcessor();
        //testMapperScanPostProcessor();
        testMapperScanPostProcessor();
    }

    /**
     * 测试常用的后处理器
     */
    private static void basicTest() {
        // build an applicationContext
        GenericApplicationContext context = new GenericApplicationContext();
        context.registerBean("config", Config.class);

        /* 加入BeanFactoryPostProcessor*/
        // 能够解析@ComponentScan @Bean @Import @ImportResource 注解
        context.registerBean(ConfigurationClassPostProcessor.class);

        // 扫描mybatis中的Mapper接口，并将其注入BeanFactory 可以解析@MapperScan注解
        context.registerBean(MapperScannerConfigurer.class);

        // init context
        context.refresh();

        // getBeanNames
        for (String name : context.getBeanDefinitionNames()) {
            System.out.println(name);
        }

        // destroy the context
        context.close();
    }

    /**
     * 模拟ConfigurationClassPostProcessor Bean工厂后处理器的解析@ComponentScan注解
     */
    private static void testComponentScanClassPostProcessor() throws IOException {
        // find Config.class 中的ComponentScan注解
        GenericApplicationContext context = new GenericApplicationContext();

        /* 找到ComponentScan所要扫描的包下的所有类，并判断其是否添加了@Component注解 */
        ComponentScan annotation = AnnotationUtils.findAnnotation(Config.class, ComponentScan.class);
        if (annotation != null) {
            // edu.seu.deep_in_spring.beanFactoryPostProcessor.component
            // -> classpath:*edu/seu/deep_in_spring/beanFactoryPostProcessor/component/**/*.class
            for (String p : annotation.basePackages()) {
                System.out.println(p);
                String path = "classpath*:" + p.replace(".", "/") + "/**/*.class";
                System.out.println(path);
                Resource[] resources = context.getResources(path);

                // factory to read metadata in resources
                CachingMetadataReaderFactory factory = new CachingMetadataReaderFactory();

                // bean name generator (generated by Annotation)
                AnnotationBeanNameGenerator generator = new AnnotationBeanNameGenerator();

                for (Resource resource : resources) {

                    // 使用MetadataReader读取资源信息(包含类信息， 注解信息等)
                    MetadataReader reader = factory.getMetadataReader(resource);
                    // 打印类名
                    System.out.println("className:" + reader.getClassMetadata().getClassName());
                    // 打印该类是否添加了@Component注解

                    // Bean2 true Bean3 false Bean4 false
                    System.out.println("hasComponent:" +
                            reader.getAnnotationMetadata().hasAnnotation(Component.class.getName()));
                    // 打印该类是否添加了@Component的派生(@Controller等)注解

                    // Bean2 false Bean3 true Bean4 false
                    System.out.println("hasComponent派生:" +
                            reader.getAnnotationMetadata().hasMetaAnnotation(Component.class.getName()));


                    // if @Component or its subclass (@Controller @Service ...) is added
                    if (reader.getAnnotationMetadata().hasAnnotation(Component.class.getName())
                            || reader.getAnnotationMetadata().hasMetaAnnotation(Component.class.getName())) {
                        // build a beanDefinition by className(by reader) and BeanDefinitionBuilder
                        AbstractBeanDefinition beanDefinition = BeanDefinitionBuilder
                                .genericBeanDefinition(reader.getClassMetadata().getClassName()).getBeanDefinition();

                        /* 将BeanDefinition注册到ApplicationContext中的beanFactory */

                        DefaultListableBeanFactory beanFactory = context.getDefaultListableBeanFactory();

                        String name = generator.generateBeanName(beanDefinition, beanFactory);

                        beanFactory.registerBeanDefinition(name, beanDefinition);
                    }
                }

                // build Bean2 and Bean3
                context.refresh();
            }
        }
    }

    /**
     * 测试自定义的@ComponetScan工厂后处理器
     */
    private static void testMyBeanFactoryPostProcessor() {
        GenericApplicationContext context = new GenericApplicationContext();

        // 将自定义的后处理器加入Bean 该后处理器能解析Config中的@ComponentScan注解从而将Bean2和Bean3加入BeanFactory
        context.registerBean(MyComponentScanPostProcessor.class);
        context.registerBean(Config.class);

        // 执行后处理器
        context.refresh();
        for (String name : context.getBeanDefinitionNames()) {
            System.out.println(name);
        }
    }

    /**
     * 模拟ConfigurationClassPostProcessor Bean工厂后处理器的解析@Bean注解
     * 被@Configuration注解的类相当于工厂类， 而@Bean注解的方法相当于工厂方法
     */
    private static void testBeanPostProcessor() throws IOException {
        GenericApplicationContext context = new GenericApplicationContext();
        CachingMetadataReaderFactory factory = new CachingMetadataReaderFactory();
        MetadataReader reader = factory.getMetadataReader(new ClassPathResource("edu/seu/deep_in_spring/beanFactoryPostProcessor/Config.class"));
        // 获取Config.class下所有被@Bean注解标注的method
        Set<MethodMetadata> annotatedMethods = reader.getAnnotationMetadata().getAnnotatedMethods(Bean.class.getName());
        for (MethodMetadata method : annotatedMethods) {
            // System.out.println(method);

             // 根据metadata创建对应的BeanDefinition
            BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition();
            // 设置工厂方法
            builder.setFactoryMethodOnBean(method.getMethodName(), "config");

            // 设置自动装配模式 装配工厂方法的参数 -> 构造方法和工厂方法(@Bean)的自动装配模式需要选择AUTOWIRE_CONSTRUCTOR
            builder.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_CONSTRUCTOR);

            // 获取@Bean注解属性
            String initMethod = Objects.requireNonNull(method.getAnnotationAttributes(Bean.class.getName())).get("initMethod").toString();
            if (initMethod != null && initMethod.length() > 0) {
                builder.setInitMethodName(initMethod);
            }

            AbstractBeanDefinition beanDefinition = builder.getBeanDefinition();
            // 将beanDefinition放入beanFactory
            context.getDefaultListableBeanFactory().registerBeanDefinition(method.getMethodName(), beanDefinition);
        }

        for (String name : context.getBeanDefinitionNames()) {
            System.out.println(name);
        }
    }

    /**
     * 模拟实现解析@MapperScan的后处理器的过程
     * 该模拟方法通过在@Configuration中创建@Bean方法并通过工厂后处理器解析，将@Mapper注入，缺点是Mapper只能一个一个注入
     */
    private static void testMapperScanPostProcessor() {
        GenericApplicationContext context = new GenericApplicationContext();
        context.registerBean("config", Config.class);
        context.registerBean(AtBeanFactoryPostProcessor.class);
        context.refresh();
        for (String name : context.getBeanDefinitionNames()) {
            System.out.println(name);
        }
    }

    /**
     * 模拟实现自定义的@MapperScan工厂后处理器, 该工厂后处理器可以解析@MapperScan接口
     */
    private static void testMyMapperScanPostProcessor() {
        GenericApplicationContext context = new GenericApplicationContext();
        context.registerBean("config", Config.class);
        // 加入自定义的Bean工厂后处理器
        context.registerBean(MapperPostScanPostProcessor.class);
        context.refresh();
        for (String name : context.getBeanDefinitionNames()) {
            System.out.println(name);
        }
    }
}
